/* Copyright (c) 2023 - 2023, Oracle and/or its affiliates. All rights reserved. */
/* Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/. */

//
// @file 
//
// Analysis related to the Control Flow Graph (CFG) of the CI pipeline.
//

#ifndef _CFG_ANALYSIS_DL_
#define _CFG_ANALYSIS_DL_

#include "facts.dl"

.decl BlockExists(block:Block)
.decl WriteExists(writeStmt:WriteStmt)
.decl ParentBlock(block:Block, parentBlock:Block)
.decl AncestorBlock(block:Block, ancestorBlock:Block)


//
// A CFG element exists if it appears anywhere in the control flow representation
//

BlockExists(block) :-
    (SequentialBlock(block) ; 
    SequentialBlockEntry(block, _) ;
    SequentialBlockEdge(block, _, _) ;
    SequentialBlockEdge(_, block, _) ;
    SequentialBlockEdge(_, _, block)).

BlockExists(block) :-
    (SchedulerBlock(block) ;
    SchedulerBlockMember(block, _) ;
    SchedulerBlockMember(_, block) ;
    SchedulerBlockDependency(block, _, _) ;
    SchedulerBlockDependency(_, block, _) ;
    SchedulerBlockDependency(_, _, block)).

BlockExists(block) :-
    (StatementBlock(block) ;
    StatementBlockMember(block, _)).

BlockExists(block) :-
    (OperationBlock(block) ;
    OperationType(block, _) ;
    OperationSubBlock(block, _) ;
    OperationSubBlock(_, block)).

WriteExists(writeStmt) :-
    (Write(writeStmt, _, _) ;
    WriteForEach(writeStmt, _, _, _) ;
    StatementBlockMember(_, writeStmt)
    ).

//
// Compute direct containing parent block for each element, as well
// as transitive closure of ancestors.
//

ParentBlock(block, parentBlock) :-
    (SequentialBlockEntry(parentBlock, block) ; 
        SequentialBlockEdge(parentBlock, block, _) ; 
        SequentialBlockEdge(parentBlock, _, block) ;
        SchedulerBlockMember(parentBlock, block) ;
        OperationSubBlock(parentBlock, block)).

AncestorBlock(block, ancestorBlock) :-
    ParentBlock(block, ancestorBlock).

AncestorBlock(block, ancestorBlock) :-
    AncestorBlock(block, intermediateBlock),
    ParentBlock(intermediateBlock, ancestorBlock).

.decl AncestorBlockOrSelf(block:Block, ancestorBlock:Block)

AncestorBlockOrSelf(block, block) :-
    BlockExists(block).

AncestorBlockOrSelf(block, ancestorBlock) :-
    AncestorBlock(block, ancestorBlock).

#ifdef DEBUG_OUTPUT
.output ParentBlock(IO=stdout)
.output AncestorBlock(IO=stdout)
.output AncestorBlockOrSelf(IO=stdout)
#endif


//
// Compute transitive closure of sequential block successor edges and scheduler block dependency relations
// to establish overall precedence relations within a block.
//

.decl SequentialBlockTransitiveEdge(containingBlock:Block, beforeBlock:Block, afterBlock:Block)

SequentialBlockTransitiveEdge(containingBlock, beforeBlock, afterBlock) :-
    SequentialBlockEdge(containingBlock, beforeBlock, afterBlock).

SequentialBlockTransitiveEdge(containingBlock, beforeBlock, afterBlock) :-
    SequentialBlockTransitiveEdge(containingBlock, beforeBlock, intermediateBlock),
    SequentialBlockEdge(containingBlock, intermediateBlock, afterBlock).

#ifdef DEBUG_OUTPUT
.output SequentialBlockTransitiveEdge(IO=stdout)
#endif

.decl SchedulerBlockTransitiveDependency(containingBlock:Block, block:Block, precedingBlock:Block)

SchedulerBlockTransitiveDependency(containingBlock, block, precedingBlock) :-
    SchedulerBlockDependency(containingBlock, block, precedingBlock).

SchedulerBlockTransitiveDependency(containingBlock, block, precedingBlock) :-
    SchedulerBlockTransitiveDependency(containingBlock, block, intermediateElement),
    SequentialBlockEdge(containingBlock, intermediateElement, precedingBlock).

#ifdef DEBUG_OUTPUT
.output SchedulerBlockTransitiveDependency(IO=stdout)
#endif


//
// Compute reachability of each block from the top-level block.
// (mainly useful for sanity checking the input CFG facts)
//

.decl ReachableBlock(block:Block)

ReachableBlock(block) :-
    TopLevelBlock(block).

ReachableBlock(block) :-
    ReachableBlock(prevBlock),
    SequentialBlockEntry(prevBlock, block).

ReachableBlock(block) :-
    ReachableBlock(prevBlock),
    SequentialBlockEdge(_, prevBlock, block).

ReachableBlock(block) :-
    ReachableBlock(prevBlock),
    SchedulerBlockMember(prevBlock, block).

ReachableBlock(block) :-
    ReachableBlock(prevBlock),
    OperationSubBlock(prevBlock, block).


// A well-formed CFG shouldn't have anything unreachable.
.decl UnreachableBlock(block:Block)

UnreachableBlock(block) :-
    BlockExists(block),
    !ReachableBlock(block).

.decl UnreachableWrite(writeStmt:WriteStmt)

UnreachableWrite(writeStmt) :-
    WriteExists(writeStmt),
    !StatementBlockMember(_, writeStmt).

UnreachableWrite(writeStmt) :-
    WriteExists(writeStmt),
    StatementBlockMember(block, writeStmt),
    UnreachableBlock(block).

#ifdef DEBUG_OUTPUT
.output UnreachableBlock(IO=stdout)
.output UnreachableWrite(IO=stdout)
#endif


//
// Compute precedence of CFG nodes across the whole program.
// Essentially, find the nearest common ancestor block of both CFG nodes,
// and check whether one must follow the other at that level in that block.
// A block itself is considered to be before its contained elements.
//

.decl BlockMayFollow(beforeBlock:Block, afterBlock:Block)

BlockMayFollow(beforeBlock, afterBlock) :-
    AncestorBlockOrSelf(beforeBlock, beforeAncestorBlock),
    AncestorBlockOrSelf(afterBlock, afterAncestorBlock),
    SequentialBlock(commonBlock),
    SequentialBlockTransitiveEdge(commonBlock, beforeAncestorBlock, afterAncestorBlock).

BlockMayFollow(beforeBlock, afterBlock) :-
    AncestorBlockOrSelf(beforeBlock, beforeAncestorBlock),
    AncestorBlockOrSelf(afterBlock, afterAncestorBlock),
    SchedulerBlock(commonBlock),
    !SchedulerBlockTransitiveDependency(commonBlock, beforeAncestorBlock, afterAncestorBlock).

BlockMayFollow(beforeBlock, afterBlock) :-
    OperationSubBlock(beforeBlock, afterBlock).

.decl WriteMayFollow(beforeWrite:WriteStmt, afterWrite:WriteStmt)

WriteMayFollow(beforeWrite, afterWrite) :-
    StatementBlockMember(beforeBlock, beforeWrite),
    StatementBlockMember(afterBlock, afterWrite),
    BlockMayFollow(beforeBlock, afterBlock).

.decl WriteMayFollowBlock(beforeBlock:Block, afterWrite:WriteStmt)

WriteMayFollowBlock(beforeBlock, afterWrite) :-
    StatementBlockMember(afterBlock, afterWrite),
    BlockMayFollow(beforeBlock, afterBlock).

WriteMayFollowBlock(block, write) :-
    StatementBlockMember(block, write).

.decl BlockMayFollowWrite(beforeWrite:WriteStmt, afterBlock:Block)

BlockMayFollowWrite(beforeWrite, afterBlock) :-
    StatementBlockMember(beforeBlock, beforeWrite),
    BlockMayFollow(beforeBlock, afterBlock).


#ifdef DEBUG_OUTPUT
.output BlockMayFollow(IO=stdout)
.output WriteMayFollow(IO=stdout)
.output WriteMayFollowBlock(IO=stdout)
.output BlockMayFollowWrite(IO=stdout)
#endif

#endif